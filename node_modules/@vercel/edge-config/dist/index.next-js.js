// src/index.next-js.ts
import { cacheLife } from "next/cache";

// package.json
var name = "@vercel/edge-config";
var version = "1.4.3";

// src/utils/tracing.ts
var edgeConfigTraceSymbol = Symbol.for("@vercel/edge-config:global-trace");
function setTracerProvider(tracer) {
  Reflect.set(globalThis, edgeConfigTraceSymbol, tracer);
}
function getTracer() {
  const maybeTraceApi = Reflect.get(globalThis, edgeConfigTraceSymbol);
  return maybeTraceApi == null ? void 0 : maybeTraceApi.getTracer(name, version);
}
function isPromise(p) {
  return p !== null && typeof p === "object" && "then" in p && typeof p.then === "function";
}
function trace(fn, options = {
  name: fn.name
}) {
  const traced = function(...args) {
    const tracer = getTracer();
    if (!tracer) return fn.apply(this, args);
    const shouldTrace = process.env.EDGE_CONFIG_TRACE_VERBOSE === "true" || options.isVerboseTrace === false;
    if (!shouldTrace) return fn.apply(this, args);
    return tracer.startActiveSpan(options.name, (span) => {
      if (options.attributes) span.setAttributes(options.attributes);
      try {
        const result = fn.apply(this, args);
        if (isPromise(result)) {
          result.then((value) => {
            if (options.attributesSuccess) {
              span.setAttributes(
                options.attributesSuccess(
                  value
                )
              );
            }
            span.setStatus({ code: 1 });
            span.end();
          }).catch((error) => {
            if (options.attributesError) {
              span.setAttributes(options.attributesError(error));
            }
            span.setStatus({
              code: 2,
              // 2 = Error
              message: error instanceof Error ? error.message : void 0
            });
            span.end();
          });
        } else {
          if (options.attributesSuccess) {
            span.setAttributes(options.attributesSuccess(result));
          }
          span.setStatus({ code: 1 });
          span.end();
        }
        return result;
      } catch (error) {
        if (options.attributesError) {
          span.setAttributes(options.attributesError(error));
        }
        span.setStatus({
          code: 2,
          // 2 = Error
          message: error instanceof Error ? error.message : void 0
        });
        span.end();
        throw error;
      }
    });
  };
  return traced;
}

// src/utils/index.ts
var ERRORS = {
  UNAUTHORIZED: "@vercel/edge-config: Unauthorized",
  EDGE_CONFIG_NOT_FOUND: "@vercel/edge-config: Edge Config not found"
};
var UnexpectedNetworkError = class extends Error {
  constructor(res) {
    super(
      `@vercel/edge-config: Unexpected error due to response with status code ${res.status}`
    );
  }
};
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function pick(obj, keys) {
  const ret = {};
  keys.forEach((key) => {
    ret[key] = obj[key];
  });
  return ret;
}
function assertIsKey(key) {
  if (typeof key !== "string") {
    throw new Error("@vercel/edge-config: Expected key to be a string");
  }
}
function isEmptyKey(key) {
  return key.trim() === "";
}
function assertIsKeys(keys) {
  if (!Array.isArray(keys) || keys.some((key) => typeof key !== "string")) {
    throw new Error(
      "@vercel/edge-config: Expected keys to be an array of string"
    );
  }
}
var clone = trace(
  function clone2(value) {
    if (typeof structuredClone === "function") return structuredClone(value);
    if (value === void 0) return value;
    return JSON.parse(JSON.stringify(value));
  },
  { name: "clone" }
);
function parseVercelConnectionStringFromUrl(text) {
  try {
    const url = new URL(text);
    if (url.host !== "edge-config.vercel.com") return null;
    if (url.protocol !== "https:") return null;
    if (!url.pathname.startsWith("/ecfg")) return null;
    const id = url.pathname.split("/")[1];
    if (!id) return null;
    const token = url.searchParams.get("token");
    if (!token || token === "") return null;
    return {
      type: "vercel",
      baseUrl: `https://edge-config.vercel.com/${id}`,
      id,
      version: "1",
      token
    };
  } catch {
    return null;
  }
}
function parseConnectionFromQueryParams(text) {
  try {
    if (!text.startsWith("edge-config:")) return null;
    const params = new URLSearchParams(text.slice(12));
    const id = params.get("id");
    const token = params.get("token");
    if (!id || !token) return null;
    return {
      type: "vercel",
      baseUrl: `https://edge-config.vercel.com/${id}`,
      id,
      version: "1",
      token
    };
  } catch {
  }
  return null;
}
function parseExternalConnectionStringFromUrl(connectionString) {
  try {
    const url = new URL(connectionString);
    let id = url.searchParams.get("id");
    const token = url.searchParams.get("token");
    const version2 = url.searchParams.get("version") || "1";
    if (!id || url.pathname.startsWith("/ecfg_")) {
      id = url.pathname.split("/")[1] || null;
    }
    if (!id || !token) return null;
    url.search = "";
    return {
      type: "external",
      baseUrl: url.toString(),
      id,
      token,
      version: version2
    };
  } catch {
    return null;
  }
}
function parseConnectionString(connectionString) {
  return parseConnectionFromQueryParams(connectionString) || parseVercelConnectionStringFromUrl(connectionString) || parseExternalConnectionStringFromUrl(connectionString);
}

// src/create-create-client.ts
function createCreateClient({
  getInMemoryEdgeConfig: getInMemoryEdgeConfig2,
  getLocalEdgeConfig: getLocalEdgeConfig2,
  fetchEdgeConfigItem: fetchEdgeConfigItem2,
  fetchEdgeConfigHas: fetchEdgeConfigHas2,
  fetchAllEdgeConfigItem: fetchAllEdgeConfigItem2,
  fetchEdgeConfigTrace: fetchEdgeConfigTrace2
}) {
  return trace(
    function createClient2(connectionString, options = {
      staleIfError: 604800,
      cache: "no-store"
    }) {
      if (!connectionString)
        throw new Error("@vercel/edge-config: No connection string provided");
      const connection = parseConnectionString(connectionString);
      if (!connection)
        throw new Error(
          "@vercel/edge-config: Invalid connection string provided"
        );
      const edgeConfigId = connection.id;
      const baseUrl = connection.baseUrl;
      const version2 = connection.version;
      const headers = {
        Authorization: `Bearer ${connection.token}`
      };
      if (typeof process !== "undefined" && process.env.VERCEL_ENV)
        headers["x-edge-config-vercel-env"] = process.env.VERCEL_ENV;
      if (typeof name === "string" && typeof version === "string")
        headers["x-edge-config-sdk"] = `${name}@${version}`;
      if (typeof options.staleIfError === "number" && options.staleIfError > 0)
        headers["cache-control"] = `stale-if-error=${options.staleIfError}`;
      const fetchCache = options.cache || "no-store";
      const shouldUseDevelopmentCache = !options.disableDevelopmentCache && process.env.NODE_ENV === "development" && process.env.EDGE_CONFIG_DISABLE_DEVELOPMENT_SWR !== "1";
      const api = {
        get: trace(
          async function get2(key, localOptions) {
            assertIsKey(key);
            let localEdgeConfig = null;
            if (localOptions == null ? void 0 : localOptions.consistentRead) {
            } else if (shouldUseDevelopmentCache) {
              localEdgeConfig = await getInMemoryEdgeConfig2(
                connectionString,
                fetchCache,
                options.staleIfError
              );
            } else {
              localEdgeConfig = await getLocalEdgeConfig2(
                connection.type,
                connection.id,
                fetchCache
              );
            }
            if (localEdgeConfig) {
              if (isEmptyKey(key)) return void 0;
              return Promise.resolve(localEdgeConfig.items[key]);
            }
            return fetchEdgeConfigItem2(
              baseUrl,
              key,
              version2,
              localOptions == null ? void 0 : localOptions.consistentRead,
              headers,
              fetchCache
            );
          },
          { name: "get", isVerboseTrace: false, attributes: { edgeConfigId } }
        ),
        has: trace(
          async function has2(key, localOptions) {
            assertIsKey(key);
            if (isEmptyKey(key)) return false;
            let localEdgeConfig = null;
            if (localOptions == null ? void 0 : localOptions.consistentRead) {
            } else if (shouldUseDevelopmentCache) {
              localEdgeConfig = await getInMemoryEdgeConfig2(
                connectionString,
                fetchCache,
                options.staleIfError
              );
            } else {
              localEdgeConfig = await getLocalEdgeConfig2(
                connection.type,
                connection.id,
                fetchCache
              );
            }
            if (localEdgeConfig) {
              return Promise.resolve(
                hasOwnProperty(localEdgeConfig.items, key)
              );
            }
            return fetchEdgeConfigHas2(
              baseUrl,
              key,
              version2,
              localOptions == null ? void 0 : localOptions.consistentRead,
              headers,
              fetchCache
            );
          },
          { name: "has", isVerboseTrace: false, attributes: { edgeConfigId } }
        ),
        getAll: trace(
          async function getAll2(keys, localOptions) {
            if (keys) {
              assertIsKeys(keys);
            }
            let localEdgeConfig = null;
            if (localOptions == null ? void 0 : localOptions.consistentRead) {
            } else if (shouldUseDevelopmentCache) {
              localEdgeConfig = await getInMemoryEdgeConfig2(
                connectionString,
                fetchCache,
                options.staleIfError
              );
            } else {
              localEdgeConfig = await getLocalEdgeConfig2(
                connection.type,
                connection.id,
                fetchCache
              );
            }
            if (localEdgeConfig) {
              if (keys === void 0) {
                return Promise.resolve(localEdgeConfig.items);
              }
              return Promise.resolve(pick(localEdgeConfig.items, keys));
            }
            return fetchAllEdgeConfigItem2(
              baseUrl,
              keys,
              version2,
              localOptions == null ? void 0 : localOptions.consistentRead,
              headers,
              fetchCache
            );
          },
          {
            name: "getAll",
            isVerboseTrace: false,
            attributes: { edgeConfigId }
          }
        ),
        digest: trace(
          async function digest2(localOptions) {
            let localEdgeConfig = null;
            if (localOptions == null ? void 0 : localOptions.consistentRead) {
            } else if (shouldUseDevelopmentCache) {
              localEdgeConfig = await getInMemoryEdgeConfig2(
                connectionString,
                fetchCache,
                options.staleIfError
              );
            } else {
              localEdgeConfig = await getLocalEdgeConfig2(
                connection.type,
                connection.id,
                fetchCache
              );
            }
            if (localEdgeConfig) {
              return Promise.resolve(localEdgeConfig.digest);
            }
            return fetchEdgeConfigTrace2(
              baseUrl,
              version2,
              localOptions == null ? void 0 : localOptions.consistentRead,
              headers,
              fetchCache
            );
          },
          {
            name: "digest",
            isVerboseTrace: false,
            attributes: { edgeConfigId }
          }
        )
      };
      return { ...api, connection };
    },
    {
      name: "createClient"
    }
  );
}

// src/edge-config.ts
import { readFile } from "@vercel/edge-config-fs";

// src/utils/fetch-with-cached-response.ts
function createResponse(cachedResponseEntry) {
  return new Response(cachedResponseEntry.response, {
    headers: {
      ...cachedResponseEntry.headers,
      Age: String(
        // age header may not be 0 when serving stale content, must be >= 1
        Math.max(1, Math.floor((Date.now() - cachedResponseEntry.time) / 1e3))
      )
    },
    status: cachedResponseEntry.status
  });
}
function createHandleStaleIfError(cachedResponseEntry, staleIfError) {
  return function handleStaleIfError(response) {
    switch (response.status) {
      case 500:
      case 502:
      case 503:
      case 504:
        return typeof staleIfError === "number" && cachedResponseEntry.time < Date.now() + staleIfError * 1e3 ? createResponse(cachedResponseEntry) : response;
      default:
        return response;
    }
  };
}
function createHandleStaleIfErrorException(cachedResponseEntry, staleIfError) {
  return function handleStaleIfError(reason) {
    if (typeof staleIfError === "number" && cachedResponseEntry.time < Date.now() + staleIfError * 1e3) {
      return createResponse(cachedResponseEntry);
    }
    throw reason;
  };
}
var cache = /* @__PURE__ */ new Map();
function extractStaleIfError(cacheControlHeader) {
  if (!cacheControlHeader) return null;
  const matched = /stale-if-error=(?<staleIfError>\d+)/i.exec(
    cacheControlHeader
  );
  return (matched == null ? void 0 : matched.groups) ? Number(matched.groups.staleIfError) : null;
}
var fetchWithCachedResponse = trace(
  async function fetchWithCachedResponse2(url, options = {}) {
    const { headers: customHeaders = new Headers(), ...customOptions } = options;
    const authHeader = customHeaders.get("Authorization");
    const cacheKey = `${url},${authHeader || ""}`;
    const cachedResponseEntry = cache.get(cacheKey);
    if (cachedResponseEntry) {
      const { etag: etag2, response: cachedResponse } = cachedResponseEntry;
      const headers = new Headers(customHeaders);
      headers.set("If-None-Match", etag2);
      const staleIfError = extractStaleIfError(headers.get("Cache-Control"));
      const res2 = await fetch(url, {
        ...customOptions,
        headers
      }).then(
        createHandleStaleIfError(cachedResponseEntry, staleIfError),
        createHandleStaleIfErrorException(cachedResponseEntry, staleIfError)
      );
      if (res2.status === 304) {
        res2.cachedResponseBody = JSON.parse(cachedResponse);
        return res2;
      }
      const newETag = res2.headers.get("ETag");
      if (res2.ok && newETag)
        cache.set(cacheKey, {
          etag: newETag,
          response: await res2.clone().text(),
          headers: Object.fromEntries(res2.headers.entries()),
          status: res2.status,
          time: Date.now()
        });
      return res2;
    }
    const res = await fetch(url, options);
    const etag = res.headers.get("ETag");
    if (res.ok && etag) {
      cache.set(cacheKey, {
        etag,
        response: await res.clone().text(),
        headers: Object.fromEntries(res.headers.entries()),
        status: res.status,
        time: Date.now()
      });
    }
    return res;
  },
  {
    name: "fetchWithCachedResponse",
    attributesSuccess(result) {
      return {
        status: result.status
      };
    }
  }
);

// src/edge-config.ts
var X_EDGE_CONFIG_SDK_HEADER = typeof name === "string" && typeof version === "string" ? `${name}@${version}` : "";
var jsonParseCache = /* @__PURE__ */ new Map();
var readFileTraced = trace(readFile, { name: "readFile" });
var jsonParseTraced = trace(JSON.parse, { name: "JSON.parse" });
var privateEdgeConfigSymbol = Symbol.for("privateEdgeConfig");
var cachedJsonParseTraced = trace(
  (edgeConfigId, content) => {
    const cached = jsonParseCache.get(edgeConfigId);
    if (cached) return cached;
    const parsed = jsonParseTraced(content);
    jsonParseCache.set(edgeConfigId, Object.freeze(parsed));
    return parsed;
  },
  { name: "cached JSON.parse" }
);
var getFileSystemEdgeConfig = trace(
  async function getFileSystemEdgeConfig2(connectionType, connectionId) {
    if (connectionType !== "vercel") return null;
    if (!process.env.AWS_LAMBDA_FUNCTION_NAME) return null;
    try {
      const content = await readFileTraced(
        `/opt/edge-config/${connectionId}.json`,
        "utf-8"
      );
      return cachedJsonParseTraced(connectionId, content);
    } catch {
      return null;
    }
  },
  {
    name: "getFileSystemEdgeConfig"
  }
);
var getPrivateEdgeConfig = trace(
  async function getPrivateEdgeConfig2(connectionId) {
    const privateEdgeConfig = Reflect.get(
      globalThis,
      privateEdgeConfigSymbol
    );
    if (typeof privateEdgeConfig === "object" && typeof privateEdgeConfig.get === "function") {
      return privateEdgeConfig.get(connectionId);
    }
    return null;
  },
  {
    name: "getPrivateEdgeConfig"
  }
);
async function getLocalEdgeConfig(connectionType, connectionId, _fetchCache) {
  const edgeConfig = await getPrivateEdgeConfig(connectionId) || await getFileSystemEdgeConfig(connectionType, connectionId);
  return edgeConfig;
}
var inMemoryEdgeConfigsGetterMap = /* @__PURE__ */ new Map();
function getOrCreateGetInMemoryEdgeConfigByConnection(connectionString) {
  const getConfig = inMemoryEdgeConfigsGetterMap.get(connectionString);
  if (getConfig) return getConfig;
  const newGetConfig = (() => {
    const connection = parseConnectionString(connectionString);
    if (!connection)
      throw new Error(
        "@vercel/edge-config: Invalid connection string provided"
      );
    const headersRecord = {
      Authorization: `Bearer ${connection.token}`
    };
    if (typeof process !== "undefined" && process.env.VERCEL_ENV)
      headersRecord["x-edge-config-vercel-env"] = process.env.VERCEL_ENV;
    if (X_EDGE_CONFIG_SDK_HEADER)
      headersRecord["x-edge-config-sdk"] = X_EDGE_CONFIG_SDK_HEADER;
    let embeddedEdgeConfigPromise = null;
    let latestRequest = null;
    return trace(
      (fetchCache, staleIfError) => {
        if (!latestRequest) {
          const headers = new Headers(headersRecord);
          if (typeof staleIfError === "number" && staleIfError > 0) {
            headers.set("cache-control", `stale-if-error=${staleIfError}`);
          } else {
            headers.delete("cache-control");
          }
          latestRequest = fetchWithCachedResponse(
            `${connection.baseUrl}/items?version=${connection.version}`,
            {
              headers,
              cache: fetchCache
            }
          ).then(async (res) => {
            const digest2 = res.headers.get("x-edge-config-digest");
            let body;
            if (!res.ok) {
              await consumeResponseBody(res);
              body = res.cachedResponseBody;
              if (!body) return null;
            } else {
              body = await res.json();
            }
            return { digest: digest2, items: body };
          });
          latestRequest.then(
            (resolved) => {
              embeddedEdgeConfigPromise = Promise.resolve(resolved);
              latestRequest = null;
            },
            // Attach a `.catch` handler to this promise so that if it does throw,
            // we don't get an unhandled promise rejection event. We unset the
            // `latestRequest` so that the next call will make a new request.
            () => {
              embeddedEdgeConfigPromise = null;
              latestRequest = null;
            }
          );
        }
        if (!embeddedEdgeConfigPromise) {
          embeddedEdgeConfigPromise = latestRequest;
        }
        return embeddedEdgeConfigPromise;
      },
      {
        name: "getInMemoryEdgeConfig"
      }
    );
  })();
  inMemoryEdgeConfigsGetterMap.set(connectionString, newGetConfig);
  return newGetConfig;
}
async function getInMemoryEdgeConfig(connectionString, fetchCache, staleIfError) {
  const getConfig = getOrCreateGetInMemoryEdgeConfigByConnection(connectionString);
  return getConfig(fetchCache, staleIfError);
}
async function fetchEdgeConfigItem(baseUrl, key, version2, consistentRead, localHeaders, fetchCache) {
  if (isEmptyKey(key)) return void 0;
  const headers = new Headers(localHeaders);
  if (consistentRead) {
    addConsistentReadHeader(headers);
  }
  return fetchWithCachedResponse(`${baseUrl}/item/${key}?version=${version2}`, {
    headers,
    cache: fetchCache
  }).then(async (res) => {
    if (res.ok) return res.json();
    await consumeResponseBody(res);
    if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);
    if (res.status === 404) {
      if (res.headers.has("x-edge-config-digest")) return void 0;
      throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);
    }
    if (res.cachedResponseBody !== void 0)
      return res.cachedResponseBody;
    throw new UnexpectedNetworkError(res);
  });
}
async function fetchEdgeConfigHas(baseUrl, key, version2, consistentRead, localHeaders, fetchCache) {
  const headers = new Headers(localHeaders);
  if (consistentRead) {
    addConsistentReadHeader(headers);
  }
  return fetch(`${baseUrl}/item/${key}?version=${version2}`, {
    method: "HEAD",
    headers,
    cache: fetchCache
  }).then((res) => {
    if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);
    if (res.status === 404) {
      if (res.headers.has("x-edge-config-digest")) return false;
      throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);
    }
    if (res.ok) return true;
    throw new UnexpectedNetworkError(res);
  });
}
async function fetchAllEdgeConfigItem(baseUrl, keys, version2, consistentRead, localHeaders, fetchCache) {
  let url = `${baseUrl}/items?version=${version2}`;
  if (keys) {
    if (keys.length === 0) return Promise.resolve({});
    const nonEmptyKeys = keys.filter(
      (key) => typeof key === "string" && !isEmptyKey(key)
    );
    if (nonEmptyKeys.length === 0) return Promise.resolve({});
    url += `&${new URLSearchParams(
      nonEmptyKeys.map((key) => ["key", key])
    ).toString()}`;
  }
  const headers = new Headers(localHeaders);
  if (consistentRead) {
    addConsistentReadHeader(headers);
  }
  return fetchWithCachedResponse(url, {
    headers,
    cache: fetchCache
  }).then(async (res) => {
    if (res.ok) return res.json();
    await consumeResponseBody(res);
    if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);
    if (res.status === 404) throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);
    if (res.cachedResponseBody !== void 0)
      return res.cachedResponseBody;
    throw new UnexpectedNetworkError(res);
  });
}
async function fetchEdgeConfigTrace(baseUrl, version2, consistentRead, localHeaders, fetchCache) {
  const headers = new Headers(localHeaders);
  if (consistentRead) {
    addConsistentReadHeader(headers);
  }
  return fetchWithCachedResponse(`${baseUrl}/digest?version=${version2}`, {
    headers,
    cache: fetchCache
  }).then(async (res) => {
    if (res.ok) return res.json();
    await consumeResponseBody(res);
    if (res.cachedResponseBody !== void 0)
      return res.cachedResponseBody;
    throw new UnexpectedNetworkError(res);
  });
}
function addConsistentReadHeader(headers) {
  headers.set("x-edge-config-min-updated-at", `${Number.MAX_SAFE_INTEGER}`);
}
async function consumeResponseBody(res) {
  await res.arrayBuffer();
}

// src/index.next-js.ts
function setCacheLifeFromFetchCache(fetchCache) {
  try {
    if (fetchCache === "force-cache") {
      cacheLife("default");
    } else {
      cacheLife({ revalidate: 0, expire: 0 });
      cacheLife({ stale: 60 });
    }
  } catch {
  }
}
async function getInMemoryEdgeConfigForNext(...args) {
  "use cache";
  const fetchCache = args[1];
  setCacheLifeFromFetchCache(fetchCache);
  return getInMemoryEdgeConfig(...args);
}
async function getLocalEdgeConfigForNext(...args) {
  "use cache";
  const [type, id, fetchCache] = args;
  setCacheLifeFromFetchCache(fetchCache);
  return getLocalEdgeConfig(type, id, fetchCache);
}
async function fetchEdgeConfigItemForNext(...args) {
  "use cache";
  const fetchCache = args[5];
  setCacheLifeFromFetchCache(fetchCache);
  return fetchEdgeConfigItem(...args);
}
async function fetchEdgeConfigHasForNext(...args) {
  "use cache";
  const fetchCache = args[5];
  setCacheLifeFromFetchCache(fetchCache);
  return fetchEdgeConfigHas(...args);
}
async function fetchAllEdgeConfigItemForNext(...args) {
  "use cache";
  const fetchCache = args[5];
  setCacheLifeFromFetchCache(fetchCache);
  return fetchAllEdgeConfigItem(...args);
}
async function fetchEdgeConfigTraceForNext(...args) {
  "use cache";
  const fetchCache = args[4];
  setCacheLifeFromFetchCache(fetchCache);
  return fetchEdgeConfigTrace(...args);
}
var createClient = createCreateClient({
  getInMemoryEdgeConfig: getInMemoryEdgeConfigForNext,
  getLocalEdgeConfig: getLocalEdgeConfigForNext,
  fetchEdgeConfigItem: fetchEdgeConfigItemForNext,
  fetchEdgeConfigHas: fetchEdgeConfigHasForNext,
  fetchAllEdgeConfigItem: fetchAllEdgeConfigItemForNext,
  fetchEdgeConfigTrace: fetchEdgeConfigTraceForNext
});
var defaultEdgeConfigClient;
function init() {
  if (!defaultEdgeConfigClient) {
    defaultEdgeConfigClient = createClient(process.env.EDGE_CONFIG);
  }
}
var get = (...args) => {
  init();
  return defaultEdgeConfigClient.get(...args);
};
var getAll = (...args) => {
  init();
  return defaultEdgeConfigClient.getAll(...args);
};
var has = (...args) => {
  init();
  return defaultEdgeConfigClient.has(...args);
};
var digest = (...args) => {
  init();
  return defaultEdgeConfigClient.digest(...args);
};
function clone3(edgeConfigValue) {
  return JSON.parse(JSON.stringify(edgeConfigValue));
}
export {
  clone3 as clone,
  createClient,
  digest,
  get,
  getAll,
  has,
  parseConnectionString,
  setTracerProvider
};
//# sourceMappingURL=index.next-js.js.map