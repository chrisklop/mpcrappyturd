{"version":3,"sources":["../package.json","../src/utils/tracing.ts","../src/utils/index.ts","../src/create-create-client.ts","../src/edge-config.ts","../src/utils/fetch-with-cached-response.ts","../src/index.ts"],"sourcesContent":["{\n  \"name\": \"@vercel/edge-config\",\n  \"version\": \"1.4.3\",\n  \"description\": \"Ultra-low latency data at the edge\",\n  \"homepage\": \"https://vercel.com\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/vercel/storage.git\",\n    \"directory\": \"packages/edge-config\"\n  },\n  \"license\": \"Apache-2.0\",\n  \"sideEffects\": false,\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": {\n      \"next-js\": {\n        \"import\": \"./dist/index.next-js.js\",\n        \"require\": \"./dist/index.next-js.cjs\"\n      },\n      \"import\": \"./dist/index.js\",\n      \"require\": \"./dist/index.cjs\"\n    }\n  },\n  \"main\": \"./dist/index.cjs\",\n  \"module\": \"./dist/index.js\",\n  \"files\": [\n    \"dist\"\n  ],\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"dev\": \"tsup --watch --clean=false\",\n    \"lint\": \"eslint --max-warnings=0 .\",\n    \"prepublishOnly\": \"pnpm run build\",\n    \"prettier-check\": \"prettier --check .\",\n    \"publint\": \"npx publint\",\n    \"test\": \"pnpm run test:node && pnpm run test:edge && pnpm run test:common\",\n    \"test:common\": \"jest --env @edge-runtime/jest-environment .common.test.ts && jest --env node .common.test.ts\",\n    \"test:edge\": \"jest --env @edge-runtime/jest-environment .edge.test.ts\",\n    \"test:node\": \"jest --env node .node.test.ts\",\n    \"type-check\": \"tsc --noEmit\"\n  },\n  \"jest\": {\n    \"preset\": \"ts-jest\",\n    \"setupFiles\": [\n      \"<rootDir>/jest/setup.js\"\n    ],\n    \"testEnvironment\": \"node\"\n  },\n  \"dependencies\": {\n    \"@vercel/edge-config-fs\": \"workspace:*\"\n  },\n  \"devDependencies\": {\n    \"@changesets/cli\": \"2.28.1\",\n    \"@edge-runtime/jest-environment\": \"2.3.10\",\n    \"@edge-runtime/types\": \"2.2.9\",\n    \"@types/jest\": \"29.5.14\",\n    \"@types/node\": \"22.13.5\",\n    \"eslint\": \"8.56.0\",\n    \"eslint-config-custom\": \"workspace:*\",\n    \"jest\": \"29.7.0\",\n    \"jest-fetch-mock\": \"3.0.3\",\n    \"next\": \"16.0.0-canary.15\",\n    \"node-domexception\": \"2.0.1\",\n    \"prettier\": \"3.5.2\",\n    \"ts-jest\": \"29.2.6\",\n    \"tsconfig\": \"workspace:*\",\n    \"tsup\": \"8.4.0\",\n    \"typescript\": \"5.7.3\"\n  },\n  \"peerDependencies\": {\n    \"@opentelemetry/api\": \"^1.7.0\",\n    \"next\": \">=1\"\n  },\n  \"peerDependenciesMeta\": {\n    \"@opentelemetry/api\": {\n      \"optional\": true\n    },\n    \"next\": {\n      \"optional\": true\n    }\n  },\n  \"engines\": {\n    \"node\": \">=14.6\"\n  }\n}\n","import type { Tracer, Attributes, TracerProvider } from '@opentelemetry/api';\nimport { name as pkgName, version } from '../../package.json';\n\n// Use a symbol to avoid having global variable that is scoped to this file,\n// as it can lead to issues with cjs and mjs being used at the same time.\nconst edgeConfigTraceSymbol = Symbol.for('@vercel/edge-config:global-trace');\n\n/**\n * Allows setting the `@opentelemetry/api` tracer provider to generate traces\n * for Edge Config related operations.\n */\nexport function setTracerProvider(tracer: TracerProvider): void {\n  Reflect.set(globalThis, edgeConfigTraceSymbol, tracer);\n}\n\nfunction getTracer(): Tracer | undefined {\n  const maybeTraceApi = Reflect.get(globalThis, edgeConfigTraceSymbol) as\n    | undefined\n    | TracerProvider;\n  return maybeTraceApi?.getTracer(pkgName, version);\n}\n\nfunction isPromise<T>(p: unknown): p is Promise<T> {\n  return (\n    p !== null &&\n    typeof p === 'object' &&\n    'then' in p &&\n    typeof p.then === 'function'\n  );\n}\n\n/* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any -- bc */\nexport function trace<F extends (...args: any) => any>(\n  fn: F,\n  options: {\n    name: string;\n    /** Defaults to `true`. If set to `false`, it'll trace regardless of `EDGE_CONFIG_TRACE_VERBOSE`. */\n    isVerboseTrace?: boolean;\n    attributes?: Attributes;\n    attributesSuccess?: (\n      result: ReturnType<F> extends PromiseLike<infer U> ? U : ReturnType<F>,\n    ) => Attributes;\n    attributesError?: (error: Error) => Attributes;\n  } = {\n    name: fn.name,\n  },\n): F {\n  const traced = function (this: unknown, ...args: unknown[]): unknown {\n    const tracer = getTracer();\n    if (!tracer) return fn.apply(this, args);\n\n    const shouldTrace =\n      process.env.EDGE_CONFIG_TRACE_VERBOSE === 'true' ||\n      options.isVerboseTrace === false;\n    if (!shouldTrace) return fn.apply(this, args);\n\n    return tracer.startActiveSpan(options.name, (span) => {\n      if (options.attributes) span.setAttributes(options.attributes);\n\n      try {\n        const result = fn.apply(this, args);\n\n        if (isPromise(result)) {\n          result\n            .then((value) => {\n              if (options.attributesSuccess) {\n                span.setAttributes(\n                  options.attributesSuccess(\n                    value as ReturnType<F> extends PromiseLike<infer U>\n                      ? U\n                      : ReturnType<F>,\n                  ),\n                );\n              }\n\n              span.setStatus({ code: 1 }); // 1 = Ok\n              span.end();\n            })\n            .catch((error) => {\n              if (options.attributesError) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- k\n                span.setAttributes(options.attributesError(error));\n              }\n\n              span.setStatus({\n                code: 2, // 2 = Error\n                message: error instanceof Error ? error.message : undefined,\n              });\n\n              span.end();\n            });\n        } else {\n          if (options.attributesSuccess) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- k\n            span.setAttributes(options.attributesSuccess(result));\n          }\n\n          span.setStatus({ code: 1 }); // 1 = Ok\n          span.end();\n        }\n\n        return result as unknown;\n      } catch (error: any) {\n        if (options.attributesError) {\n          span.setAttributes(options.attributesError(error as Error));\n        }\n\n        span.setStatus({\n          code: 2, // 2 = Error\n          message: error instanceof Error ? error.message : undefined,\n        });\n\n        span.end();\n\n        throw error;\n      }\n    });\n  };\n\n  return traced as unknown as F;\n}\n/* eslint-enable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any -- k */\n","import type { Connection } from '../types';\nimport { trace } from './tracing';\n\nexport const ERRORS = {\n  UNAUTHORIZED: '@vercel/edge-config: Unauthorized',\n  EDGE_CONFIG_NOT_FOUND: '@vercel/edge-config: Edge Config not found',\n};\n\nexport class UnexpectedNetworkError extends Error {\n  constructor(res: Response) {\n    super(\n      `@vercel/edge-config: Unexpected error due to response with status code ${res.status}`,\n    );\n  }\n}\n\n/**\n * Checks if an object has a property\n */\nexport function hasOwnProperty<X, Y extends PropertyKey>(\n  obj: X,\n  prop: Y,\n): obj is X & Record<Y, unknown> {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nexport function pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n  const ret: Partial<T> = {};\n  keys.forEach((key) => {\n    ret[key] = obj[key];\n  });\n  return ret as Pick<T, K>;\n}\n\nexport function assertIsKey(key: unknown): asserts key is string {\n  if (typeof key !== 'string') {\n    throw new Error('@vercel/edge-config: Expected key to be a string');\n  }\n}\n\nexport function isEmptyKey(key: string): boolean {\n  return key.trim() === '';\n}\n\nexport function assertIsKeys(keys: unknown): asserts keys is string[] {\n  if (!Array.isArray(keys) || keys.some((key) => typeof key !== 'string')) {\n    throw new Error(\n      '@vercel/edge-config: Expected keys to be an array of string',\n    );\n  }\n}\n\n/**\n * Creates a deep clone of an object.\n */\nexport const clone = trace(\n  function clone<T>(value: T): T {\n    // only available since node v17.0.0\n    if (typeof structuredClone === 'function') return structuredClone<T>(value);\n\n    // poor man's polyfill for structuredClone\n    if (value === undefined) return value;\n    return JSON.parse(JSON.stringify(value)) as T;\n  },\n  { name: 'clone' },\n);\n\n/**\n * Parses internal edge config connection strings\n *\n * Internal edge config connection strings are those which are native to Vercel.\n *\n * Internal Edge Config Connection Strings look like this:\n * https://edge-config.vercel.com/<edgeConfigId>?token=<token>\n */\nfunction parseVercelConnectionStringFromUrl(text: string): Connection | null {\n  try {\n    const url = new URL(text);\n    if (url.host !== 'edge-config.vercel.com') return null;\n    if (url.protocol !== 'https:') return null;\n    if (!url.pathname.startsWith('/ecfg')) return null;\n\n    const id = url.pathname.split('/')[1];\n    if (!id) return null;\n\n    const token = url.searchParams.get('token');\n    if (!token || token === '') return null;\n\n    return {\n      type: 'vercel',\n      baseUrl: `https://edge-config.vercel.com/${id}`,\n      id,\n      version: '1',\n      token,\n    };\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Parses a connection string with the following format:\n * `edge-config:id=ecfg_abcd&token=xxx`\n */\nfunction parseConnectionFromQueryParams(text: string): Connection | null {\n  try {\n    if (!text.startsWith('edge-config:')) return null;\n    const params = new URLSearchParams(text.slice(12));\n\n    const id = params.get('id');\n    const token = params.get('token');\n\n    if (!id || !token) return null;\n\n    return {\n      type: 'vercel',\n      baseUrl: `https://edge-config.vercel.com/${id}`,\n      id,\n      version: '1',\n      token,\n    };\n  } catch {\n    // no-op\n  }\n\n  return null;\n}\n\n/**\n * Parses info contained in connection strings.\n *\n * This works with the vercel-provided connection strings, but it also\n * works with custom connection strings.\n *\n * The reason we support custom connection strings is that it makes testing\n * edge config really straightforward. Users can provide  connection strings\n * pointing to their own servers and then either have a custom server\n * return the desired values or even intercept requests with something like\n * msw.\n *\n * To allow interception we need a custom connection string as the\n * edge-config.vercel.com connection string might not always go over\n * the network, so msw would not have a chance to intercept.\n */\n/**\n * Parses external edge config connection strings\n *\n * External edge config connection strings are those which are foreign to Vercel.\n *\n * External Edge Config Connection Strings look like this:\n * - https://example.com/?id=<edgeConfigId>&token=<token>\n * - https://example.com/<edgeConfigId>?token=<token>\n */\nfunction parseExternalConnectionStringFromUrl(\n  connectionString: string,\n): Connection | null {\n  try {\n    const url = new URL(connectionString);\n\n    let id: string | null = url.searchParams.get('id');\n    const token = url.searchParams.get('token');\n    const version = url.searchParams.get('version') || '1';\n\n    // try to determine id based on pathname if it wasn't provided explicitly\n    if (!id || url.pathname.startsWith('/ecfg_')) {\n      id = url.pathname.split('/')[1] || null;\n    }\n\n    if (!id || !token) return null;\n\n    // remove all search params for use as baseURL\n    url.search = '';\n\n    // try to parse as external connection string\n    return {\n      type: 'external',\n      baseUrl: url.toString(),\n      id,\n      token,\n      version,\n    };\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Parse the edgeConfigId and token from an Edge Config Connection String.\n *\n * Edge Config Connection Strings usually look like one of the following:\n *  - https://edge-config.vercel.com/<edgeConfigId>?token=<token>\n *  - edge-config:id=<edgeConfigId>&token=<token>\n *\n * @param text - A potential Edge Config Connection String\n * @returns The connection parsed from the given Connection String or null.\n */\nexport function parseConnectionString(\n  connectionString: string,\n): Connection | null {\n  return (\n    parseConnectionFromQueryParams(connectionString) ||\n    parseVercelConnectionStringFromUrl(connectionString) ||\n    parseExternalConnectionStringFromUrl(connectionString)\n  );\n}\n","import { name as sdkName, version as sdkVersion } from '../package.json';\nimport type * as deps from './edge-config';\nimport type {\n  EdgeConfigClient,\n  EdgeConfigFunctionsOptions,\n  EdgeConfigItems,\n  EdgeConfigValue,\n  EmbeddedEdgeConfig,\n} from './types';\nimport {\n  assertIsKey,\n  assertIsKeys,\n  hasOwnProperty,\n  isEmptyKey,\n  parseConnectionString,\n  pick,\n} from './utils';\nimport { trace } from './utils/tracing';\n\ntype CreateClient = (\n  connectionString: string | undefined,\n  options?: deps.EdgeConfigClientOptions,\n) => EdgeConfigClient;\n\nexport function createCreateClient({\n  getInMemoryEdgeConfig,\n  getLocalEdgeConfig,\n  fetchEdgeConfigItem,\n  fetchEdgeConfigHas,\n  fetchAllEdgeConfigItem,\n  fetchEdgeConfigTrace,\n}: {\n  getInMemoryEdgeConfig: typeof deps.getInMemoryEdgeConfig;\n  getLocalEdgeConfig: typeof deps.getLocalEdgeConfig;\n  fetchEdgeConfigItem: typeof deps.fetchEdgeConfigItem;\n  fetchEdgeConfigHas: typeof deps.fetchEdgeConfigHas;\n  fetchAllEdgeConfigItem: typeof deps.fetchAllEdgeConfigItem;\n  fetchEdgeConfigTrace: typeof deps.fetchEdgeConfigTrace;\n}): CreateClient {\n  /**\n   * Create an Edge Config client.\n   *\n   * The client has multiple methods which allow you to read the Edge Config.\n   *\n   * If you need to programmatically write to an Edge Config, check out the [Update your Edge Config items](https://vercel.com/docs/storage/edge-config/vercel-api#update-your-edge-config-items) section.\n   *\n   * @param connectionString - A connection string. Usually you'd pass in `process.env.EDGE_CONFIG` here, which contains a connection string.\n   * @returns An Edge Config Client instance\n   */\n  return trace(\n    function createClient(\n      connectionString,\n      options = {\n        staleIfError: 604800 /* one week */,\n        cache: 'no-store',\n      },\n    ): EdgeConfigClient {\n      if (!connectionString)\n        throw new Error('@vercel/edge-config: No connection string provided');\n\n      const connection = parseConnectionString(connectionString);\n\n      if (!connection)\n        throw new Error(\n          '@vercel/edge-config: Invalid connection string provided',\n        );\n\n      const edgeConfigId = connection.id;\n      const baseUrl = connection.baseUrl;\n      const version = connection.version; // version of the edge config read access api we talk to\n      const headers: Record<string, string> = {\n        Authorization: `Bearer ${connection.token}`,\n      };\n\n      // eslint-disable-next-line @typescript-eslint/prefer-optional-chain -- [@vercel/style-guide@5 migration]\n      if (typeof process !== 'undefined' && process.env.VERCEL_ENV)\n        headers['x-edge-config-vercel-env'] = process.env.VERCEL_ENV;\n\n      if (typeof sdkName === 'string' && typeof sdkVersion === 'string')\n        headers['x-edge-config-sdk'] = `${sdkName}@${sdkVersion}`;\n\n      if (typeof options.staleIfError === 'number' && options.staleIfError > 0)\n        headers['cache-control'] = `stale-if-error=${options.staleIfError}`;\n\n      const fetchCache = options.cache || 'no-store';\n\n      /**\n       * While in development we use SWR-like behavior for the api client to\n       * reduce latency.\n       */\n      const shouldUseDevelopmentCache =\n        !options.disableDevelopmentCache &&\n        process.env.NODE_ENV === 'development' &&\n        process.env.EDGE_CONFIG_DISABLE_DEVELOPMENT_SWR !== '1';\n\n      const api: Omit<EdgeConfigClient, 'connection'> = {\n        get: trace(\n          async function get<T = EdgeConfigValue>(\n            key: string,\n            localOptions?: EdgeConfigFunctionsOptions,\n          ): Promise<T | undefined> {\n            assertIsKey(key);\n\n            let localEdgeConfig: EmbeddedEdgeConfig | null = null;\n            if (localOptions?.consistentRead) {\n              // fall through to fetching\n            } else if (shouldUseDevelopmentCache) {\n              localEdgeConfig = await getInMemoryEdgeConfig(\n                connectionString,\n                fetchCache,\n                options.staleIfError,\n              );\n            } else {\n              localEdgeConfig = await getLocalEdgeConfig(\n                connection.type,\n                connection.id,\n                fetchCache,\n              );\n            }\n\n            if (localEdgeConfig) {\n              if (isEmptyKey(key)) return undefined;\n              // We need to return a clone of the value so users can't modify\n              // our original value, and so the reference changes.\n              //\n              // This makes it consistent with the real API.\n              return Promise.resolve(localEdgeConfig.items[key] as T);\n            }\n\n            return fetchEdgeConfigItem<T>(\n              baseUrl,\n              key,\n              version,\n              localOptions?.consistentRead,\n              headers,\n              fetchCache,\n            );\n          },\n          { name: 'get', isVerboseTrace: false, attributes: { edgeConfigId } },\n        ),\n        has: trace(\n          async function has(\n            key,\n            localOptions?: EdgeConfigFunctionsOptions,\n          ): Promise<boolean> {\n            assertIsKey(key);\n            if (isEmptyKey(key)) return false;\n\n            let localEdgeConfig: EmbeddedEdgeConfig | null = null;\n\n            if (localOptions?.consistentRead) {\n              // fall through to fetching\n            } else if (shouldUseDevelopmentCache) {\n              localEdgeConfig = await getInMemoryEdgeConfig(\n                connectionString,\n                fetchCache,\n                options.staleIfError,\n              );\n            } else {\n              localEdgeConfig = await getLocalEdgeConfig(\n                connection.type,\n                connection.id,\n                fetchCache,\n              );\n            }\n\n            if (localEdgeConfig) {\n              return Promise.resolve(\n                hasOwnProperty(localEdgeConfig.items, key),\n              );\n            }\n\n            return fetchEdgeConfigHas(\n              baseUrl,\n              key,\n              version,\n              localOptions?.consistentRead,\n              headers,\n              fetchCache,\n            );\n          },\n          { name: 'has', isVerboseTrace: false, attributes: { edgeConfigId } },\n        ),\n        getAll: trace(\n          async function getAll<T = EdgeConfigItems>(\n            keys?: (keyof T)[],\n            localOptions?: EdgeConfigFunctionsOptions,\n          ): Promise<T> {\n            if (keys) {\n              assertIsKeys(keys);\n            }\n\n            let localEdgeConfig: EmbeddedEdgeConfig | null = null;\n\n            if (localOptions?.consistentRead) {\n              // fall through to fetching\n            } else if (shouldUseDevelopmentCache) {\n              localEdgeConfig = await getInMemoryEdgeConfig(\n                connectionString,\n                fetchCache,\n                options.staleIfError,\n              );\n            } else {\n              localEdgeConfig = await getLocalEdgeConfig(\n                connection.type,\n                connection.id,\n                fetchCache,\n              );\n            }\n\n            if (localEdgeConfig) {\n              if (keys === undefined) {\n                return Promise.resolve(localEdgeConfig.items as T);\n              }\n\n              return Promise.resolve(pick(localEdgeConfig.items, keys) as T);\n            }\n\n            return fetchAllEdgeConfigItem<T>(\n              baseUrl,\n              keys,\n              version,\n              localOptions?.consistentRead,\n              headers,\n              fetchCache,\n            );\n          },\n          {\n            name: 'getAll',\n            isVerboseTrace: false,\n            attributes: { edgeConfigId },\n          },\n        ),\n        digest: trace(\n          async function digest(\n            localOptions?: EdgeConfigFunctionsOptions,\n          ): Promise<string> {\n            let localEdgeConfig: EmbeddedEdgeConfig | null = null;\n\n            if (localOptions?.consistentRead) {\n              // fall through to fetching\n            } else if (shouldUseDevelopmentCache) {\n              localEdgeConfig = await getInMemoryEdgeConfig(\n                connectionString,\n                fetchCache,\n                options.staleIfError,\n              );\n            } else {\n              localEdgeConfig = await getLocalEdgeConfig(\n                connection.type,\n                connection.id,\n                fetchCache,\n              );\n            }\n\n            if (localEdgeConfig) {\n              return Promise.resolve(localEdgeConfig.digest);\n            }\n\n            return fetchEdgeConfigTrace(\n              baseUrl,\n              version,\n              localOptions?.consistentRead,\n              headers,\n              fetchCache,\n            );\n          },\n          {\n            name: 'digest',\n            isVerboseTrace: false,\n            attributes: { edgeConfigId },\n          },\n        ),\n      };\n\n      return { ...api, connection };\n    },\n    {\n      name: 'createClient',\n    },\n  );\n}\n","import { readFile } from '@vercel/edge-config-fs';\nimport { name as sdkName, version as sdkVersion } from '../package.json';\nimport type {\n  Connection,\n  EdgeConfigItems,\n  EdgeConfigValue,\n  EmbeddedEdgeConfig,\n} from './types';\nimport {\n  ERRORS,\n  isEmptyKey,\n  parseConnectionString,\n  UnexpectedNetworkError,\n} from './utils';\nimport { fetchWithCachedResponse } from './utils/fetch-with-cached-response';\nimport { trace } from './utils/tracing';\n\nconst X_EDGE_CONFIG_SDK_HEADER =\n  typeof sdkName === 'string' && typeof sdkVersion === 'string'\n    ? `${sdkName}@${sdkVersion}`\n    : '';\n\ntype HeadersRecord = Record<string, string>;\n\nconst jsonParseCache = new Map<string, unknown>();\n\nconst readFileTraced = trace(readFile, { name: 'readFile' });\nconst jsonParseTraced = trace(JSON.parse, { name: 'JSON.parse' });\n\nconst privateEdgeConfigSymbol = Symbol.for('privateEdgeConfig');\n\nconst cachedJsonParseTraced = trace(\n  (edgeConfigId: string, content: string) => {\n    const cached = jsonParseCache.get(edgeConfigId);\n    if (cached) return cached;\n\n    const parsed = jsonParseTraced(content) as unknown;\n\n    // freeze the object to avoid mutations of the return value of a \"get\" call\n    // from affecting the return value of future \"get\" calls\n    jsonParseCache.set(edgeConfigId, Object.freeze(parsed));\n    return parsed;\n  },\n  { name: 'cached JSON.parse' },\n);\n\n/**\n * Reads an Edge Config from the local file system.\n * This is used at runtime on serverless functions.\n */\nconst getFileSystemEdgeConfig = trace(\n  async function getFileSystemEdgeConfig(\n    connectionType: Connection['type'],\n    connectionId: Connection['id'],\n  ): Promise<EmbeddedEdgeConfig | null> {\n    // can't optimize non-vercel hosted edge configs\n    if (connectionType !== 'vercel') return null;\n    // can't use fs optimizations outside of lambda\n    if (!process.env.AWS_LAMBDA_FUNCTION_NAME) return null;\n\n    try {\n      const content = await readFileTraced(\n        `/opt/edge-config/${connectionId}.json`,\n        'utf-8',\n      );\n\n      return cachedJsonParseTraced(connectionId, content) as EmbeddedEdgeConfig;\n    } catch {\n      return null;\n    }\n  },\n  {\n    name: 'getFileSystemEdgeConfig',\n  },\n);\n\n/**\n * Will return an embedded Edge Config object from memory,\n * but only when the `privateEdgeConfigSymbol` is in global scope.\n */\nconst getPrivateEdgeConfig = trace(\n  async function getPrivateEdgeConfig(\n    connectionId: Connection['id'],\n  ): Promise<EmbeddedEdgeConfig | null> {\n    const privateEdgeConfig = Reflect.get(\n      globalThis,\n      privateEdgeConfigSymbol,\n    ) as\n      | {\n          get: (id: string) => Promise<EmbeddedEdgeConfig | null>;\n        }\n      | undefined;\n\n    if (\n      typeof privateEdgeConfig === 'object' &&\n      typeof privateEdgeConfig.get === 'function'\n    ) {\n      return privateEdgeConfig.get(connectionId);\n    }\n\n    return null;\n  },\n  {\n    name: 'getPrivateEdgeConfig',\n  },\n);\n\n/**\n * Reads the Edge Config from a local provider, if available,\n * to avoid Network requests.\n */\nexport async function getLocalEdgeConfig(\n  connectionType: Connection['type'],\n  connectionId: Connection['id'],\n  _fetchCache: EdgeConfigClientOptions['cache'],\n): Promise<EmbeddedEdgeConfig | null> {\n  const edgeConfig =\n    (await getPrivateEdgeConfig(connectionId)) ||\n    (await getFileSystemEdgeConfig(connectionType, connectionId));\n\n  return edgeConfig;\n}\n\ntype GetConfigFunction = (\n  fetchCache: EdgeConfigClientOptions['cache'],\n  staleIfError: EdgeConfigClientOptions['staleIfError'],\n) => Promise<EmbeddedEdgeConfig | null>;\nconst inMemoryEdgeConfigsGetterMap = new Map<string, GetConfigFunction>();\nfunction getOrCreateGetInMemoryEdgeConfigByConnection(\n  connectionString: string,\n): GetConfigFunction {\n  const getConfig = inMemoryEdgeConfigsGetterMap.get(connectionString);\n  if (getConfig) return getConfig;\n\n  const newGetConfig = (() => {\n    const connection = parseConnectionString(connectionString);\n\n    if (!connection)\n      throw new Error(\n        '@vercel/edge-config: Invalid connection string provided',\n      );\n\n    const headersRecord: HeadersRecord = {\n      Authorization: `Bearer ${connection.token}`,\n    };\n\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain -- [@vercel/style-guide@5 migration]\n    if (typeof process !== 'undefined' && process.env.VERCEL_ENV)\n      headersRecord['x-edge-config-vercel-env'] = process.env.VERCEL_ENV;\n\n    if (X_EDGE_CONFIG_SDK_HEADER)\n      headersRecord['x-edge-config-sdk'] = X_EDGE_CONFIG_SDK_HEADER;\n\n    // Functions as cache to keep track of the Edge Config.\n    let embeddedEdgeConfigPromise: Promise<EmbeddedEdgeConfig | null> | null =\n      null;\n\n    // Promise that points to the most recent request.\n    // It'll ensure that subsequent calls won't make another fetch call,\n    // while one is still on-going.\n    // Will overwrite `embeddedEdgeConfigPromise` only when resolved.\n    let latestRequest: Promise<EmbeddedEdgeConfig | null> | null = null;\n\n    return trace(\n      (\n        fetchCache: EdgeConfigClientOptions['cache'],\n        staleIfError: EdgeConfigClientOptions['staleIfError'],\n      ) => {\n        if (!latestRequest) {\n          const headers = new Headers(headersRecord);\n          if (typeof staleIfError === 'number' && staleIfError > 0) {\n            headers.set('cache-control', `stale-if-error=${staleIfError}`);\n          } else {\n            headers.delete('cache-control');\n          }\n\n          latestRequest = fetchWithCachedResponse(\n            `${connection.baseUrl}/items?version=${connection.version}`,\n            {\n              headers,\n              cache: fetchCache,\n            },\n          ).then(async (res) => {\n            const digest = res.headers.get('x-edge-config-digest');\n            let body: EdgeConfigValue | undefined;\n\n            // We ignore all errors here and just proceed.\n            if (!res.ok) {\n              await consumeResponseBody(res);\n              body = res.cachedResponseBody as EdgeConfigValue | undefined;\n              if (!body) return null;\n            } else {\n              body = (await res.json()) as EdgeConfigItems;\n            }\n\n            return { digest, items: body } as EmbeddedEdgeConfig;\n          });\n\n          // Once the request is resolved, we set the proper config to the promise\n          // such that the next call will return the resolved value.\n          latestRequest.then(\n            (resolved) => {\n              embeddedEdgeConfigPromise = Promise.resolve(resolved);\n              latestRequest = null;\n            },\n            // Attach a `.catch` handler to this promise so that if it does throw,\n            // we don't get an unhandled promise rejection event. We unset the\n            // `latestRequest` so that the next call will make a new request.\n            () => {\n              embeddedEdgeConfigPromise = null;\n              latestRequest = null;\n            },\n          );\n        }\n\n        if (!embeddedEdgeConfigPromise) {\n          // If the `embeddedEdgeConfigPromise` is `null`, it means that there's\n          // no previous request, so we'll set the `latestRequest` to the current\n          // request.\n          embeddedEdgeConfigPromise = latestRequest;\n        }\n\n        return embeddedEdgeConfigPromise;\n      },\n      {\n        name: 'getInMemoryEdgeConfig',\n      },\n    );\n  })();\n\n  inMemoryEdgeConfigsGetterMap.set(connectionString, newGetConfig);\n\n  return newGetConfig;\n}\n\n/**\n * Returns a function to retrieve the entire Edge Config.\n * It'll keep the fetched Edge Config in memory, making subsequent calls fast,\n * while revalidating in the background.\n */\nexport async function getInMemoryEdgeConfig(\n  connectionString: string,\n  fetchCache: EdgeConfigClientOptions['cache'],\n  staleIfError: EdgeConfigClientOptions['staleIfError'],\n): Promise<EmbeddedEdgeConfig | null> {\n  const getConfig =\n    getOrCreateGetInMemoryEdgeConfigByConnection(connectionString);\n  return getConfig(fetchCache, staleIfError);\n}\n\n/**\n * Fetches an edge config item from the API\n */\nexport async function fetchEdgeConfigItem<T = EdgeConfigValue>(\n  baseUrl: string,\n  key: string,\n  version: string,\n  consistentRead: undefined | boolean,\n  localHeaders: HeadersRecord,\n  fetchCache: EdgeConfigClientOptions['cache'],\n): Promise<T | undefined> {\n  if (isEmptyKey(key)) return undefined;\n\n  const headers = new Headers(localHeaders);\n  if (consistentRead) {\n    addConsistentReadHeader(headers);\n  }\n  return fetchWithCachedResponse(`${baseUrl}/item/${key}?version=${version}`, {\n    headers,\n    cache: fetchCache,\n  }).then<T | undefined, undefined>(async (res) => {\n    if (res.ok) return res.json();\n    await consumeResponseBody(res);\n\n    if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);\n    if (res.status === 404) {\n      // if the x-edge-config-digest header is present, it means\n      // the edge config exists, but the item does not\n      if (res.headers.has('x-edge-config-digest')) return undefined;\n      // if the x-edge-config-digest header is not present, it means\n      // the edge config itself does not exist\n      throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n    }\n    if (res.cachedResponseBody !== undefined)\n      return res.cachedResponseBody as T;\n    throw new UnexpectedNetworkError(res);\n  });\n}\n\n/**\n * Determines if a key exists from the API\n */\nexport async function fetchEdgeConfigHas(\n  baseUrl: string,\n  key: string,\n  version: string,\n  consistentRead: undefined | boolean,\n  localHeaders: HeadersRecord,\n  fetchCache: EdgeConfigClientOptions['cache'],\n): Promise<boolean> {\n  const headers = new Headers(localHeaders);\n  if (consistentRead) {\n    addConsistentReadHeader(headers);\n  }\n  // this is a HEAD request anyhow, no need for fetchWithCachedResponse\n  return fetch(`${baseUrl}/item/${key}?version=${version}`, {\n    method: 'HEAD',\n    headers,\n    cache: fetchCache,\n  }).then((res) => {\n    if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);\n    if (res.status === 404) {\n      // if the x-edge-config-digest header is present, it means\n      // the edge config exists, but the item does not\n      if (res.headers.has('x-edge-config-digest')) return false;\n      // if the x-edge-config-digest header is not present, it means\n      // the edge config itself does not exist\n      throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n    }\n    if (res.ok) return true;\n    throw new UnexpectedNetworkError(res);\n  });\n}\n\n/**\n * Fetches all or a list of edge config items from the API\n */\nexport async function fetchAllEdgeConfigItem<T = EdgeConfigItems>(\n  baseUrl: string,\n  keys: undefined | (keyof T)[],\n  version: string,\n  consistentRead: undefined | boolean,\n  localHeaders: HeadersRecord,\n  fetchCache: EdgeConfigClientOptions['cache'],\n): Promise<T> {\n  let url = `${baseUrl}/items?version=${version}`;\n  if (keys) {\n    if (keys.length === 0) return Promise.resolve({} as T);\n\n    const nonEmptyKeys = keys.filter(\n      (key) => typeof key === 'string' && !isEmptyKey(key),\n    );\n    if (nonEmptyKeys.length === 0) return Promise.resolve({} as T);\n\n    url += `&${new URLSearchParams(\n      nonEmptyKeys.map((key) => ['key', key] as [string, string]),\n    ).toString()}`;\n  }\n\n  const headers = new Headers(localHeaders);\n  if (consistentRead) {\n    addConsistentReadHeader(headers);\n  }\n\n  return fetchWithCachedResponse(url, {\n    headers,\n    cache: fetchCache,\n  }).then<T>(async (res) => {\n    if (res.ok) return res.json();\n    await consumeResponseBody(res);\n\n    if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);\n    // the /items endpoint never returns 404, so if we get a 404\n    // it means the edge config itself did not exist\n    if (res.status === 404) throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n    if (res.cachedResponseBody !== undefined)\n      return res.cachedResponseBody as T;\n    throw new UnexpectedNetworkError(res);\n  });\n}\n\n/**\n * Fetches all or a list of edge config items from the API\n */\nexport async function fetchEdgeConfigTrace(\n  baseUrl: string,\n  version: string,\n  consistentRead: undefined | boolean,\n  localHeaders: HeadersRecord,\n  fetchCache: EdgeConfigClientOptions['cache'],\n): Promise<string> {\n  const headers = new Headers(localHeaders);\n  if (consistentRead) {\n    addConsistentReadHeader(headers);\n  }\n\n  return fetchWithCachedResponse(`${baseUrl}/digest?version=${version}`, {\n    headers,\n    cache: fetchCache,\n  }).then(async (res) => {\n    if (res.ok) return res.json() as Promise<string>;\n    await consumeResponseBody(res);\n\n    if (res.cachedResponseBody !== undefined)\n      return res.cachedResponseBody as string;\n    throw new UnexpectedNetworkError(res);\n  });\n}\n\n/**\n * Uses `MAX_SAFE_INTEGER` as minimum updated at timestamp to force\n * a request to the origin.\n */\nfunction addConsistentReadHeader(headers: Headers): void {\n  headers.set('x-edge-config-min-updated-at', `${Number.MAX_SAFE_INTEGER}`);\n}\n\n/**\n * This function reads the respone body\n *\n * Reading the response body serves two purposes\n *\n * 1) In Node.js it avoids memory leaks\n *\n * See https://github.com/nodejs/undici/blob/v5.21.2/README.md#garbage-collection\n * See https://github.com/node-fetch/node-fetch/issues/83\n *\n * 2) In Cloudflare it avoids running into a deadlock. They have a maximum number\n * of concurrent fetches (which is documented). Concurrency counts until the\n * body of a response is read. It is not uncommon to never read a response body\n * (e.g. if you only care about the status code). This can lead to deadlock as\n * fetches appear to never resolve.\n *\n * See https://developers.cloudflare.com/workers/platform/limits/#simultaneous-open-connections\n */\nasync function consumeResponseBody(res: Response): Promise<void> {\n  await res.arrayBuffer();\n}\n\nexport interface EdgeConfigClientOptions {\n  /**\n   * The stale-if-error response directive indicates that the cache can reuse a\n   * stale response when an upstream server generates an error, or when the error\n   * is generated locally - for example due to a connection error.\n   *\n   * Any response with a status code of 500, 502, 503, or 504 is considered an error.\n   *\n   * Pass a negative number, 0, or false to turn disable stale-if-error semantics.\n   *\n   * The time is supplied in seconds. Defaults to one week (`604800`).\n   */\n  staleIfError?: number | false;\n  /**\n   * In development, a stale-while-revalidate cache is employed as the default caching strategy.\n   *\n   * This cache aims to deliver speedy Edge Config reads during development, though it comes\n   * at the cost of delayed visibility for updates to Edge Config. Typically, you may need to\n   * refresh twice to observe these changes as the stale value is replaced.\n   *\n   * This cache is not used in preview or production deployments as superior optimisations are applied there.\n   */\n  disableDevelopmentCache?: boolean;\n\n  /**\n   * Sets a `cache` option on the `fetch` call made by Edge Config.\n   *\n   * Unlike Next.js, this defaults to `no-store`, as you most likely want to use Edge Config dynamically.\n   */\n  cache?: 'no-store' | 'force-cache';\n}\n","import { trace } from './tracing';\n\ninterface CachedResponseEntry {\n  etag: string;\n  response: string;\n  headers: Record<string, string>;\n  status: number;\n  time: number;\n}\n\ntype FetchOptions = Omit<RequestInit, 'headers'> & { headers?: Headers };\n\ninterface ResponseWithCachedResponse extends Response {\n  cachedResponseBody?: unknown;\n}\n\n/**\n * Creates a new response based on a cache entry\n */\nfunction createResponse(\n  cachedResponseEntry: CachedResponseEntry,\n): ResponseWithCachedResponse {\n  return new Response(cachedResponseEntry.response, {\n    headers: {\n      ...cachedResponseEntry.headers,\n      Age: String(\n        // age header may not be 0 when serving stale content, must be >= 1\n        Math.max(1, Math.floor((Date.now() - cachedResponseEntry.time) / 1000)),\n      ),\n    },\n    status: cachedResponseEntry.status,\n  });\n}\n\n/**\n * Used for bad responses like 500s\n */\nfunction createHandleStaleIfError(\n  cachedResponseEntry: CachedResponseEntry,\n  staleIfError: number | null,\n) {\n  return function handleStaleIfError(\n    response: ResponseWithCachedResponse,\n  ): ResponseWithCachedResponse {\n    switch (response.status) {\n      case 500:\n      case 502:\n      case 503:\n      case 504:\n        return typeof staleIfError === 'number' &&\n          cachedResponseEntry.time < Date.now() + staleIfError * 1000\n          ? createResponse(cachedResponseEntry)\n          : response;\n      default:\n        return response;\n    }\n  };\n}\n\n/**\n * Used on network errors which end up throwing\n */\nfunction createHandleStaleIfErrorException(\n  cachedResponseEntry: CachedResponseEntry,\n  staleIfError: number | null,\n) {\n  return function handleStaleIfError(\n    reason: unknown,\n  ): ResponseWithCachedResponse {\n    if (\n      typeof staleIfError === 'number' &&\n      cachedResponseEntry.time < Date.now() + staleIfError * 1000\n    ) {\n      return createResponse(cachedResponseEntry);\n    }\n    throw reason;\n  };\n}\n\n/**\n * A cache of request urls & auth headers and the resulting responses.\n *\n * This cache does not use Response instances as the cache value as reusing\n * responses across requests leads to issues in Cloudflare Workers.\n */\nexport const cache = new Map<string, CachedResponseEntry>();\n\nfunction extractStaleIfError(cacheControlHeader: string | null): number | null {\n  if (!cacheControlHeader) return null;\n  const matched = /stale-if-error=(?<staleIfError>\\d+)/i.exec(\n    cacheControlHeader,\n  );\n  return matched?.groups ? Number(matched.groups.staleIfError) : null;\n}\n\n/**\n * This is similar to fetch, but it also implements ETag semantics, and\n * it implmenets stale-if-error semantics.\n */\nexport const fetchWithCachedResponse = trace(\n  async function fetchWithCachedResponse(\n    url: string,\n    options: FetchOptions = {},\n  ): Promise<ResponseWithCachedResponse> {\n    const { headers: customHeaders = new Headers(), ...customOptions } =\n      options;\n    const authHeader = customHeaders.get('Authorization');\n    const cacheKey = `${url},${authHeader || ''}`;\n\n    const cachedResponseEntry = cache.get(cacheKey);\n\n    if (cachedResponseEntry) {\n      const { etag, response: cachedResponse } = cachedResponseEntry;\n      const headers = new Headers(customHeaders);\n      headers.set('If-None-Match', etag);\n\n      const staleIfError = extractStaleIfError(headers.get('Cache-Control'));\n\n      const res: ResponseWithCachedResponse = await fetch(url, {\n        ...customOptions,\n        headers,\n      }).then(\n        createHandleStaleIfError(cachedResponseEntry, staleIfError),\n        createHandleStaleIfErrorException(cachedResponseEntry, staleIfError),\n      );\n\n      if (res.status === 304) {\n        res.cachedResponseBody = JSON.parse(cachedResponse);\n        return res;\n      }\n\n      const newETag = res.headers.get('ETag');\n      if (res.ok && newETag)\n        cache.set(cacheKey, {\n          etag: newETag,\n          response: await res.clone().text(),\n          headers: Object.fromEntries(res.headers.entries()),\n          status: res.status,\n          time: Date.now(),\n        });\n      return res;\n    }\n\n    const res = await fetch(url, options);\n    const etag = res.headers.get('ETag');\n    if (res.ok && etag) {\n      cache.set(cacheKey, {\n        etag,\n        response: await res.clone().text(),\n        headers: Object.fromEntries(res.headers.entries()),\n        status: res.status,\n        time: Date.now(),\n      });\n    }\n\n    return res;\n  },\n  {\n    name: 'fetchWithCachedResponse',\n    attributesSuccess(result) {\n      return {\n        status: result.status,\n      };\n    },\n  },\n);\n","import { createCreateClient } from './create-create-client';\nimport {\n  fetchAllEdgeConfigItem,\n  fetchEdgeConfigHas,\n  fetchEdgeConfigItem,\n  fetchEdgeConfigTrace,\n  getInMemoryEdgeConfig,\n  getLocalEdgeConfig,\n} from './edge-config';\nimport type {\n  EdgeConfigClient,\n  EdgeConfigItems,\n  EdgeConfigValue,\n  EmbeddedEdgeConfig,\n} from './types';\nimport { parseConnectionString } from './utils';\n\nexport { setTracerProvider } from './utils/tracing';\n\nexport {\n  parseConnectionString,\n  type EdgeConfigClient,\n  type EdgeConfigItems,\n  type EdgeConfigValue,\n  type EmbeddedEdgeConfig,\n};\n\n/**\n * Create an Edge Config client.\n *\n * The client has multiple methods which allow you to read the Edge Config.\n *\n * If you need to programmatically write to an Edge Config, check out the [Update your Edge Config items](https://vercel.com/docs/storage/edge-config/vercel-api#update-your-edge-config-items) section.\n *\n * @param connectionString - A connection string. Usually you'd pass in `process.env.EDGE_CONFIG` here, which contains a connection string.\n * @returns An Edge Config Client instance\n */\nexport const createClient = createCreateClient({\n  getInMemoryEdgeConfig,\n  getLocalEdgeConfig,\n  fetchEdgeConfigItem,\n  fetchEdgeConfigHas,\n  fetchAllEdgeConfigItem,\n  fetchEdgeConfigTrace,\n});\n\nlet defaultEdgeConfigClient: EdgeConfigClient;\n\n// lazy init fn so the default edge config does not throw in case\n// process.env.EDGE_CONFIG is not defined and its methods are never used.\nfunction init(): void {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- [@vercel/style-guide@5 migration]\n  if (!defaultEdgeConfigClient) {\n    defaultEdgeConfigClient = createClient(process.env.EDGE_CONFIG);\n  }\n}\n\n/**\n * Reads a single item from the default Edge Config.\n *\n * This is a convenience method which reads the default Edge Config.\n * It is conceptually similar to `createClient(process.env.EDGE_CONFIG).get()`.\n *\n * @see {@link EdgeConfigClient.get}\n * @param key - the key to read\n * @returns the value stored under the given key, or undefined\n */\nexport const get: EdgeConfigClient['get'] = (...args) => {\n  init();\n  return defaultEdgeConfigClient.get(...args);\n};\n\n/**\n * Reads multiple or all values.\n *\n * This is a convenience method which reads the default Edge Config.\n * It is conceptually similar to `createClient(process.env.EDGE_CONFIG).getAll()`.\n *\n * @see {@link EdgeConfigClient.getAll}\n * @param keys - the keys to read\n * @returns the value stored under the given key, or undefined\n */\nexport const getAll: EdgeConfigClient['getAll'] = (...args) => {\n  init();\n  return defaultEdgeConfigClient.getAll(...args);\n};\n\n/**\n * Check if a given key exists in the Edge Config.\n *\n * This is a convenience method which reads the default Edge Config.\n * It is conceptually similar to `createClient(process.env.EDGE_CONFIG).has()`.\n *\n * @see {@link EdgeConfigClient.has}\n * @param key - the key to check\n * @returns true if the given key exists in the Edge Config.\n */\nexport const has: EdgeConfigClient['has'] = (...args) => {\n  init();\n  return defaultEdgeConfigClient.has(...args);\n};\n\n/**\n * Get the digest of the Edge Config.\n *\n * This is a convenience method which reads the default Edge Config.\n * It is conceptually similar to `createClient(process.env.EDGE_CONFIG).digest()`.\n *\n * @see {@link EdgeConfigClient.digest}\n * @returns The digest of the Edge Config.\n */\nexport const digest: EdgeConfigClient['digest'] = (...args) => {\n  init();\n  return defaultEdgeConfigClient.digest(...args);\n};\n\n/**\n * Safely clones a read-only Edge Config object and makes it mutable.\n */\nexport function clone<T = EdgeConfigValue>(edgeConfigValue: T): T {\n  // Use JSON.parse and JSON.stringify instead of anything else due to\n  // the value possibly being a Proxy object.\n  return JSON.parse(JSON.stringify(edgeConfigValue)) as T;\n}\n"],"mappings":"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","names":["clone","version","getInMemoryEdgeConfig","getLocalEdgeConfig","fetchEdgeConfigItem","fetchEdgeConfigHas","fetchAllEdgeConfigItem","fetchEdgeConfigTrace","createClient","version","get","has","getAll","digest","fetchWithCachedResponse","etag","res","getFileSystemEdgeConfig","getPrivateEdgeConfig","digest","version","clone"]}